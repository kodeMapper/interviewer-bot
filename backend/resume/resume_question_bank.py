"""
Resume Question Bank
Thread-safe storage for generated resume-based questions.

Features:
- Priority queue for question ordering
- Thread-safe access with mutex locks
- Deduplication
- State tracking (asked/unanswered)
- Integration with main question bank

"""

import threading
import time
import random
from typing import List, Dict, Optional, Set, Callable, Any
from dataclasses import dataclass, field
from enum import Enum
from queue import PriorityQueue
from collections import deque

from .question_generator import GeneratedQuestion, ResumeQuestionSet, QuestionDifficulty, QuestionType


class QuestionState(Enum):
    """State of a question in the bank."""
    PENDING = "pending"         # Not yet asked
    ASKED = "asked"             # Currently being asked
    ANSWERED = "answered"       # Has been answered
    SKIPPED = "skipped"         # Skipped by user


@dataclass(order=True)
class PrioritizedQuestion:
    """Question with priority for queue ordering."""
    priority: int
    question: GeneratedQuestion = field(compare=False)
    state: QuestionState = field(default=QuestionState.PENDING, compare=False)
    added_time: float = field(default_factory=time.time, compare=False)
    
    def __post_init__(self):
        # Lower priority number = higher priority
        # Priority based on: difficulty progression + type variety
        if self.priority == -1:  # Auto-calculate
            self.priority = self._calculate_priority()
    
    def _calculate_priority(self) -> int:
        """Calculate priority based on question properties."""
        base = 50
        
        # Difficulty affects order (easy first, then medium, then hard)
        difficulty_map = {
            QuestionDifficulty.EASY: 0,
            QuestionDifficulty.MEDIUM: 30,
            QuestionDifficulty.HARD: 60
        }
        base += difficulty_map.get(self.question.difficulty, 30)
        
        # Question type affects priority
        type_priority = {
            QuestionType.THEORETICAL: 10,   # Start with basics
            QuestionType.CONCEPTUAL: 15,
            QuestionType.PROJECT: 20,       # Then projects
            QuestionType.EXPERIENCE: 25,
            QuestionType.SCENARIO: 35,      # Then scenarios
            QuestionType.BEHAVIORAL: 40,
            QuestionType.PUZZLE: 50,        # Puzzles last
        }
        base += type_priority.get(self.question.question_type, 30)
        
        # Add small random factor for variety
        base += random.randint(0, 5)
        
        return base


class ResumeQuestionBank:
    """
    Thread-safe storage for resume-generated questions.
    
    Manages question lifecycle:
    1. Questions generated by GPT are added to pending queue
    2. Questions are drawn in priority order
    3. Answered questions are moved to history
    4. Supports fallback to local bank when empty
    """
    
    def __init__(self, on_question_ready: Optional[Callable[[], None]] = None):
        """
        Initialize question bank.
        
        Args:
            on_question_ready: Callback when new questions become available
        """
        # Thread safety
        self._lock = threading.RLock()
        
        # Question storage
        self._pending_queue: PriorityQueue[PrioritizedQuestion] = PriorityQueue()
        self._pending_list: List[PrioritizedQuestion] = []  # For iteration
        self._asked_questions: Dict[str, PrioritizedQuestion] = {}  # question_text -> PQ
        self._answered_history: List[Dict[str, Any]] = []
        
        # Deduplication
        self._seen_questions: Set[str] = set()
        
        # Stats
        self._total_added = 0
        self._total_asked = 0
        self._generation_complete = False
        
        # Callbacks
        self._on_question_ready = on_question_ready
        
        print("   [ResumeBank] Initialized")
    
    def add_questions(self, question_set: ResumeQuestionSet) -> int:
        """
        Add generated questions to the bank.
        
        Args:
            question_set: Set of generated questions
            
        Returns:
            Number of questions added (after deduplication)
        """
        with self._lock:
            added_count = 0
            
            current_base_priority = self._total_added * 10
            
            for i, q in enumerate(question_set.questions):
                # Deduplication check
                q_normalized = q.question.lower().strip()
                if q_normalized in self._seen_questions:
                    continue
                
                self._seen_questions.add(q_normalized)
                
                # PHASE 2.75 FIX: Preserving Gemini's Natural Flow
                # Instead of auto-sorting by difficulty (which scrambles the flow),
                # we use the generation order as the primary priority.
                # Gemini generates questions in a logical chain (Q1->Q2->Q3).
                priority = current_base_priority + (i * 10)
                
                # Create prioritized question
                pq = PrioritizedQuestion(priority=priority, question=q)
                
                self._pending_queue.put(pq)
                self._pending_list.append(pq)
                self._total_added += 1
                added_count += 1
            
            print(f"   [ResumeBank] Added {added_count} questions (total: {self._total_added})")
            
            # Notify listeners
            if added_count > 0 and self._on_question_ready:
                self._on_question_ready()
            
            return added_count
    
    def add_single_question(self, question: GeneratedQuestion, priority: int = -1) -> bool:
        """
        Add a single question to the bank.
        
        Args:
            question: Question to add
            priority: Optional priority override (-1 for auto)
            
        Returns:
            True if added, False if duplicate
        """
        with self._lock:
            q_normalized = question.question.lower().strip()
            if q_normalized in self._seen_questions:
                return False
            
            self._seen_questions.add(q_normalized)
            
            pq = PrioritizedQuestion(priority=priority, question=question)
            self._pending_queue.put(pq)
            self._pending_list.append(pq)
            self._total_added += 1
            
            if self._on_question_ready:
                self._on_question_ready()
            
            return True
    
    def get_next_question(self) -> Optional[GeneratedQuestion]:
        """
        Get the next question in priority order.
        
        Returns:
            Next question, or None if bank is empty
        """
        with self._lock:
            if self._pending_queue.empty():
                return None
            
            pq = self._pending_queue.get()
            pq.state = QuestionState.ASKED
            
            self._asked_questions[pq.question.question] = pq
            self._total_asked += 1
            
            # Remove from pending list
            self._pending_list = [p for p in self._pending_list if p.question.question != pq.question.question]
            
            return pq.question
    
    def mark_answered(
        self,
        question: GeneratedQuestion,
        answer: str,
        score: float,
        feedback: str = ""
    ) -> None:
        """
        Mark a question as answered and record the response.
        
        Args:
            question: The question that was answered
            answer: Candidate's answer
            score: Evaluation score (0-1)
            feedback: Optional feedback text
        """
        with self._lock:
            q_key = question.question
            
            if q_key in self._asked_questions:
                pq = self._asked_questions.pop(q_key)
                pq.state = QuestionState.ANSWERED
                
                self._answered_history.append({
                    "question": question.to_dict(),
                    "answer": answer,
                    "score": score,
                    "feedback": feedback,
                    "timestamp": time.time()
                })
    
    def mark_skipped(self, question: GeneratedQuestion) -> None:
        """Mark a question as skipped."""
        with self._lock:
            q_key = question.question
            
            if q_key in self._asked_questions:
                pq = self._asked_questions.pop(q_key)
                pq.state = QuestionState.SKIPPED
    
    def has_questions(self) -> bool:
        """Check if there are pending questions."""
        with self._lock:
            return not self._pending_queue.empty()
    
    def pending_count(self) -> int:
        """Get number of pending questions."""
        with self._lock:
            return len(self._pending_list)
    
    def asked_count(self) -> int:
        """Get number of questions asked so far."""
        with self._lock:
            return self._total_asked
    
    def is_generation_complete(self) -> bool:
        """Check if question generation is complete."""
        with self._lock:
            return self._generation_complete
    
    def set_generation_complete(self, complete: bool = True) -> None:
        """Mark question generation as complete."""
        with self._lock:
            self._generation_complete = complete
            print(f"   [ResumeBank] Generation marked {'complete' if complete else 'incomplete'}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get bank statistics."""
        with self._lock:
            # Count by type
            type_counts = {}
            for pq in self._pending_list:
                t = pq.question.question_type.value
                type_counts[t] = type_counts.get(t, 0) + 1
            
            # Count by difficulty
            diff_counts = {}
            for pq in self._pending_list:
                d = pq.question.difficulty.value
                diff_counts[d] = diff_counts.get(d, 0) + 1
            
            # Calculate average score
            if self._answered_history:
                avg_score = sum(h["score"] for h in self._answered_history) / len(self._answered_history)
            else:
                avg_score = 0.0
            
            return {
                "total_added": self._total_added,
                "pending": len(self._pending_list),
                "asked": self._total_asked,
                "answered": len(self._answered_history),
                "generation_complete": self._generation_complete,
                "by_type": type_counts,
                "by_difficulty": diff_counts,
                "average_score": round(avg_score, 3)
            }
    
    def get_answered_history(self) -> List[Dict[str, Any]]:
        """Get history of answered questions."""
        with self._lock:
            return self._answered_history.copy()
    
    def peek_next(self) -> Optional[GeneratedQuestion]:
        """
        Peek at the next question without removing it.
        
        Returns:
            Next question, or None if empty
        """
        with self._lock:
            if self._pending_list:
                # Get highest priority (lowest number)
                sorted_pending = sorted(self._pending_list, key=lambda x: x.priority)
                if sorted_pending:
                    return sorted_pending[0].question
            return None
    
    def get_questions_by_section(self, section: str) -> List[GeneratedQuestion]:
        """Get all pending questions for a specific resume section."""
        with self._lock:
            return [
                pq.question for pq in self._pending_list
                if pq.question.section_source.lower() == section.lower()
            ]
    
    def clear(self) -> None:
        """Clear all questions from the bank."""
        with self._lock:
            while not self._pending_queue.empty():
                try:
                    self._pending_queue.get_nowait()
                except:
                    break
            
            self._pending_list.clear()
            self._asked_questions.clear()
            self._seen_questions.clear()
            self._total_added = 0
            self._total_asked = 0
            self._generation_complete = False
            
            print("   [ResumeBank] Cleared all questions")
    
    def export_session(self) -> Dict[str, Any]:
        """Export the entire session data for reporting."""
        with self._lock:
            return {
                "stats": self.get_stats(),
                "answered_questions": self._answered_history,
                "pending_questions": [pq.question.to_dict() for pq in self._pending_list],
                "exported_at": time.time()
            }


class HybridQuestionManager:
    """
    Manages both resume-based and local question banks.
    
    Provides seamless fallback from resume questions to local bank
    when resume questions run out.
    """
    
    def __init__(
        self,
        resume_bank: ResumeQuestionBank,
        local_bank_getter: Optional[Callable[[], Optional[str]]] = None
    ):
        """
        Initialize hybrid manager.
        
        Args:
            resume_bank: Resume question bank
            local_bank_getter: Function to get questions from local bank
        """
        self.resume_bank = resume_bank
        self._get_local_question = local_bank_getter
        
        # Track source of questions
        self._resume_questions_asked = 0
        self._local_questions_asked = 0
    
    def get_next_question(self) -> Optional[Dict[str, Any]]:
        """
        Get next question, preferring resume questions.
        
        Returns:
            Dict with question info and source, or None if empty
        """
        # Try resume questions first
        resume_q = self.resume_bank.get_next_question()
        
        if resume_q:
            self._resume_questions_asked += 1
            return {
                "question": resume_q.question,
                "expected_answer": resume_q.expected_answer,
                "source": "resume",
                "type": resume_q.question_type.value,
                "difficulty": resume_q.difficulty.value,
                "section": resume_q.section_source
            }
        
        # Fallback to local bank
        if self._get_local_question:
            local_q = self._get_local_question()
            if local_q:
                self._local_questions_asked += 1
                return {
                    "question": local_q,
                    "expected_answer": "",
                    "source": "local",
                    "type": "general",
                    "difficulty": "medium",
                    "section": "general"
                }
        
        return None
    
    def get_source_stats(self) -> Dict[str, int]:
        """Get stats on question sources."""
        return {
            "resume_questions": self._resume_questions_asked,
            "local_questions": self._local_questions_asked,
            "total": self._resume_questions_asked + self._local_questions_asked
        }


# Testing
if __name__ == "__main__":
    from .question_generator import GeneratedQuestion, QuestionType, QuestionDifficulty
    
    print("Testing Resume Question Bank...")
    
    bank = ResumeQuestionBank()
    
    # Create test questions
    test_questions = [
        GeneratedQuestion(
            question="Explain your experience with Python?",
            question_type=QuestionType.THEORETICAL,
            difficulty=QuestionDifficulty.EASY,
            expected_answer="Should discuss Python projects",
            section_source="skills"
        ),
        GeneratedQuestion(
            question="What was the biggest challenge in your ML project?",
            question_type=QuestionType.PROJECT,
            difficulty=QuestionDifficulty.MEDIUM,
            expected_answer="Should discuss technical challenges",
            section_source="projects"
        ),
        GeneratedQuestion(
            question="Design a rate limiter for an API.",
            question_type=QuestionType.PUZZLE,
            difficulty=QuestionDifficulty.HARD,
            expected_answer="Token bucket or sliding window",
            section_source="skills"
        ),
    ]
    
    # Create question set and add
    from .question_generator import ResumeQuestionSet
    q_set = ResumeQuestionSet(questions=test_questions, resume_summary="Test")
    
    added = bank.add_questions(q_set)
    print(f"Added {added} questions")
    
    # Get questions in priority order
    print("\nFetching questions in priority order:")
    while bank.has_questions():
        q = bank.get_next_question()
        if q:
            print(f"  - [{q.difficulty.value}] {q.question[:50]}...")
            bank.mark_answered(q, "Sample answer", 0.8)
    
    # Print stats
    print(f"\nStats: {bank.get_stats()}")
